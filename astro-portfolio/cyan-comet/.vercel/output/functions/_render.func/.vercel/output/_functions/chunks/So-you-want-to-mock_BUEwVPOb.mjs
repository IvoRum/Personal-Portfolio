const id = "So-you-want-to-mock.md";
						const collection = "blog";
						const slug = "so-you-want-to-mock";
						const body = "\r\n# Introduction\r\n\r\nAfter creating more and more mocks over time, I've decided to revisit the topic of mocks in my blog and, more broadly, the subject of testing. In this blog post, I’m summarizing the best ways to easily test with mocks and how to use them effectively.\r\n\r\nIn other words, this post aims to show you the most useful parts of the Mockito library, so you can level up as a programmer.\r\n\r\n## Mock? What is a Mock?\r\n\r\nA mock is something that should be there, but in reality, it’s just a facade—it doesn’t actually perform any actions but simply returns what you’ve set it up to return. Just as a puppet imitates a human being, a mock imitates some logic. In a simple example, a mock can imitate a repository that we don't want to call in our test.\r\n\r\n```java\r\n    @Test\r\n    void myMockTest() {\r\n        Repo mockRepo = mock(Repo.class);\r\n        when(mockRepo.getData()).thenReturn(null);\r\n        // when\r\n\r\n\t      var data = mockRepo.getData();\r\n        // then\r\n        assertNull(data);\r\n    }\r\n```\r\n\r\nIn essence, this is a way to pull the strings of our own code so that we can test it independently, or in other words, to create a real unit test. Real unit tests do not require external help from other methods or objects. They only test a single unit of work. But how do we test a unit of work that depends on other methods? That’s where mocks come in. By using mocks, we avoid calling every method down the chain of events.\r\n\r\n## Mock Interface?\r\n\r\nYes, you can mock an implementation of an interface in any class where the interface is called. As an example, I will demonstrate mocking a Spring repository interface, but this is applicable to any interface method.\r\n\r\n```java\r\n\r\n@ExtendWith(MockitoExtension.class)\r\n@SpringBootTest\r\nclass ElMeterServiceTest {\r\n    @Mock\r\n    private InterfaceRepository interfaceRepository;\r\n    private MyService myService;\r\n\r\n    private static final String COMPANY_NAME = \"Test_Company\";\r\n\r\n    @BeforeEach\r\n    void setUp() {\r\n        myService = new MyService(interfaceRepository);\r\n    }\r\n\r\n    @Test\r\n    void InterfaceMockPositiveTest() {\r\n\t// given\r\n\tDataClass mockData = new DataClass(\"Data\");\r\n\r\n\tgiven(interfaceRepository.getDataFromRepo(123)).willReturn(Optional.of(mockData));\r\n\t// when\r\n\tDataClass dataFromService = myService.getDataFromService(123);\r\n\t// then\r\n\tassertNotNull(dataFromService);\r\n\tassertEquals(mockData, dataFromService);\r\n\r\n    }\r\n}\r\n```\r\n\r\n## Using Mockito Spy for Mocking and Using Functions as They Are\r\n\r\nSometimes you want to use mocks for just some functions. That’s where `when(..).thenCallRealMethod()` comes in.\r\n\r\nSo let's dive into the code:\r\n\r\n```java\r\n\r\nclass ServiceMockTest {\r\n    @Autowired\r\n    private MySearchService myService;\r\n    @SpyBean\r\n    private MyRepository myRepository;\r\n\r\n    @Test\r\n    void myMockTest() {\r\n        when(myService.getMs()).thenReturn(\"Hello from the mock!!\");\r\n        // when\r\n        String msResult = myService.getMs();\r\n        // then\r\n        assertEquals(\"Hello from the mock!!\", msResult);\r\n    }\r\n\r\n    @Test\r\n    void myNormalTest() {\r\n        when(myService.getMs()).thenCallRealMethod();\r\n        // when\r\n        String msResult = myService.getMs();\r\n        // then\r\n        assertEquals(\"Hello from the Real!!\", msResult);\r\n    }\r\n}\r\n\r\n```\r\n\r\nThis is how you can use mocks and real methods in one `@Autowired` test class for Spring service and repository testing.\r\n\r\n## Mocking Code That Gets Reused\r\n\r\nLet’s say you have a utility class that is used in many places in your logic, but you want to mock one call and use the real method the next time. This may happen in a loop or just in the second call. Here is an example where I mock the first call and use the real method in the second.\r\n\r\n```java\r\n@Test\r\nvoid mockOnceThenCallReal() {\r\n    // GIVEN\r\n    PersonDTO targetDTO = new PersonDTO(\r\n        company,\r\n        activityNew.getNumber(),\r\n        activityNew.getCode(),\r\n        activityNew.getStartDate(),\r\n        activityNew.getEndDate()\r\n    );\r\n    final boolean[] isCheckDone = {false};\r\n    doAnswer(invocation -> {\r\n        if (!isCheckDone[0]) {\r\n            PersonDTO argument = invocation.getArgument(0);\r\n            if (argument.equals(targetDTO)) {\r\n                isCheckDone[0] = true;\r\n                return null;\r\n            }\r\n        }\r\n        // Call the real method in subsequent calls or if the first check fails\r\n        isCheckDone[0] = true;  // Ensure this is set so that the check isn't repeated\r\n        invocation.callRealMethod();\r\n         return null;  // Since the method is void, return null\r\n    }).when(checkPersonName).validate(any(PersonDTO.class));\r\n    // WHEN THEN\r\n    assertThrows(RuntimeException.class,\r\n            () -> personService.getWorkingPeople());\r\n}\r\n```\r\n\r\nIn this case, when calling the `checkPersonName` method from the `PersonDTO` class, it will mock the first call and then use the real method, which, in this scenario, will throw a `RuntimeException`.\r\n\r\n## Final Thoughts\r\n\r\nSo that’s mainly it. This is how you will primarily use mocks for day-to-day testing. It’s not practical to dig too deep into mocking. Your mocks should be simple. If you have to mock something very complex, then you need to decompose and decouple your logic. Mocks are meant to replace something, but if you have to replace 90% of something, then what’s the point?\r\n\r\n### Links\r\n\r\nIf you want to continue reading about mocks, here are some interesting posts that I’ve read:\r\n\r\n[Spying with Mockito - to call or not to call a method](https://stevenschwenke.de/spyingWithMockito)\r\n[Mockito Verify Not Called: How to Test That a Method Was Not Called](https://hatchjs.com/mockito-verify-not-called/)\r\n";
						const data = {title:"So you want to mock",description:"Moking the usfull part",pubDate:new Date(1724965200000),heroImage:"/blog/mokito_v2.png"};
						const _internal = {
							type: 'content',
							filePath: "C:/tomcats/Personal-Portfolio/astro-portfolio/cyan-comet/src/content/blog/So-you-want-to-mock.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
