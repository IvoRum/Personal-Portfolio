import { a as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML } from './astro/server_CzNe6w_R.mjs';
import 'kleur/colors';
import 'clsx';

const html = "<p>Hello to whoever is reading this. This is my second entry into the devlog of creating a web application. In this post, I’ll explain the automation I use for the Spring application and describe my system for deployment, testing, and code quality.</p>\n<p>Here is a quick overview of how my pipeline works.</p>\n<p><img src=\"/blog/spring-pipeline/pipeline.svg\" alt=\"Pipelien diagram\"></p>\n<h1 id=\"code-repository\">Code repository</h1>\n<p>The code repository used throughout the project is GitHub, which is a reliable cloud-based repository service. Also, GitHub provides an Actions feature that can be used for CI/CD use cases, which is one of the reasons why I chose GitHub for this project. The quick and reliable use of GitHub Actions is essential for my needs.</p>\n<p>For my use case, I wanted a way to build the JAR file after merging or pushing to the main branch. I know that build files, or in other words, the ‘Artifact,’ should ideally be stored in a separate repository called an Artifact repository, which manages only the artifacts for a given project. This approach provides traceability and the option to revert to an older version of the artifact if a problem arises. However, since this is my first time creating a CI/CD pipeline, I wanted to keep things simple and add features as the project progresses. In a sense, I’m keeping scalability in mind but not focusing on it until the complete skeleton is up and running.</p>\n<p>My GitHub Actions are simple and are used just to detect a merge or push to the main branch and build a JAR artifact to be deployed.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>name: Gradle Build</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>on:</span></span>\n<span class=\"line\"><span>  push:</span></span>\n<span class=\"line\"><span>    branches: [ main ]</span></span>\n<span class=\"line\"><span>  pull_request:</span></span>\n<span class=\"line\"><span>    branches: [ main ]</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>jobs:</span></span>\n<span class=\"line\"><span>  build:</span></span>\n<span class=\"line\"><span>    runs-on: ubuntu-latest</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    steps:</span></span>\n<span class=\"line\"><span>      - uses: actions/checkout@v2</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>      - name: Set up JDK 17</span></span>\n<span class=\"line\"><span>        uses: actions/setup-java@v2</span></span>\n<span class=\"line\"><span>        with:</span></span>\n<span class=\"line\"><span>          java-version: 17</span></span>\n<span class=\"line\"><span>          distribution: 'adopt'</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>      - name: Grant execute permission for gradlew</span></span>\n<span class=\"line\"><span>        working-directory: volts-server</span></span>\n<span class=\"line\"><span>        run: chmod +x gradlew</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>      - name: Build with Gradle</span></span>\n<span class=\"line\"><span>        working-directory: volts-server</span></span>\n<span class=\"line\"><span>        run: ./gradlew build</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>      - name: List build directory</span></span>\n<span class=\"line\"><span>        working-directory: volts-server</span></span>\n<span class=\"line\"><span>        run: ls -la build/libs</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>      - name: Upload JAR file</span></span>\n<span class=\"line\"><span>        uses: actions/upload-artifact@v3</span></span>\n<span class=\"line\"><span>        with:</span></span>\n<span class=\"line\"><span>          working-directory: volts-server</span></span>\n<span class=\"line\"><span>          name: my-app-build</span></span>\n<span class=\"line\"><span>          path: build/libs/*.jar</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>      - name: Commit JAR file to repository</span></span>\n<span class=\"line\"><span>        working-directory: volts-server</span></span>\n<span class=\"line\"><span>        run: |</span></span>\n<span class=\"line\"><span>          git config user.name \"UserName\"</span></span>\n<span class=\"line\"><span>          git config user.email \"user@mail.com\"</span></span>\n<span class=\"line\"><span>          git add build/libs/*.jar</span></span>\n<span class=\"line\"><span>          git commit -m \"Add build artifacts\"</span></span>\n<span class=\"line\"><span>          git push origin main</span></span>\n<span class=\"line\"><span>        env:</span></span>\n<span class=\"line\"><span>          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}</span></span>\n<span class=\"line\"><span></span></span></code></pre>\n<h1 id=\"jenkins\">Jenkins</h1>\n<p>I use Jenkins on the server where the application will be deployed. I understand that deployment services should ideally be on a separate machine or virtual machine, but for simplicity’s sake, everything is on the same machine. The Jenkins pipeline is responsible for getting the build artifact (the JAR file), creating a Docker instance, and starting it up. However, before deployment, the code is run through SonarQube. SonarQube is a service for code quality, test coverage, code issues, and overall code assessment. SonarQube is set up as a Docker container running on the same machine. As of now, the Spring application is deployed regardless of whether the SonarQube Quality Gate fails. I chose to deploy to Docker because containers are easier and quicker to manage. The faster you use what you know, the quicker your app will be ready for use.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>pipeline {</span></span>\n<span class=\"line\"><span>    agent any</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    environment {</span></span>\n<span class=\"line\"><span>        DOCKER_IMAGE = \"100volts-server:latest\"</span></span>\n<span class=\"line\"><span>        GITHUB_REPO = \"https://github.com/100volts/100volts-server.git\"</span></span>\n<span class=\"line\"><span>        DOCKERFILE_PATH = \"volts-server/Dockerfile\"</span></span>\n<span class=\"line\"><span>        BRANCH_NAME = \"main\"</span></span>\n<span class=\"line\"><span>        SONARQUBE_SERVER = \"sonar-volts\"</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    stages {</span></span>\n<span class=\"line\"><span>        stage('Checkout') {</span></span>\n<span class=\"line\"><span>            steps {</span></span>\n<span class=\"line\"><span>                git branch: \"${BRANCH_NAME}\", url: \"${GITHUB_REPO}\"</span></span>\n<span class=\"line\"><span>            }</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        stage('Scan') {</span></span>\n<span class=\"line\"><span>            steps {</span></span>\n<span class=\"line\"><span>                dir('volts-server') {</span></span>\n<span class=\"line\"><span>                    sh 'chmod +x ./gradlew'</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>                    withSonarQubeEnv(installationName: \"${SONARQUBE_SERVER}\") {</span></span>\n<span class=\"line\"><span>                        sh './gradlew clean build sonarqube'</span></span>\n<span class=\"line\"><span>                    }</span></span>\n<span class=\"line\"><span>                }</span></span>\n<span class=\"line\"><span>            }</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        stage('Build Docker Image') {</span></span>\n<span class=\"line\"><span>            steps {</span></span>\n<span class=\"line\"><span>                script {</span></span>\n<span class=\"line\"><span>                    docker.build(\"${DOCKER_IMAGE}\", \"-f ${DOCKERFILE_PATH} volts-server/\")</span></span>\n<span class=\"line\"><span>                }</span></span>\n<span class=\"line\"><span>            }</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        stage('Run Docker Container') {</span></span>\n<span class=\"line\"><span>            steps {</span></span>\n<span class=\"line\"><span>                script {</span></span>\n<span class=\"line\"><span>                    sh \"docker stop 100volts-server || true\"</span></span>\n<span class=\"line\"><span>                    sh \"docker rm 100volts-server || true\"</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>                    sh \"docker run -d --name 100volts-server -p 8081:8081 ${DOCKER_IMAGE} --restart=always\"</span></span>\n<span class=\"line\"><span>                }</span></span>\n<span class=\"line\"><span>            }</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    post {</span></span>\n<span class=\"line\"><span>        always {</span></span>\n<span class=\"line\"><span>            // Clean up workspace</span></span>\n<span class=\"line\"><span>            cleanWs()</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span></span></span></code></pre>\n<h1 id=\"finishing-notes\">Finishing notes</h1>\n<p>Creating and managing a pipeline like this has greatly improved my scripting skills. It was exciting to build something that will save a lot of time in the long run. All in all, the exercise in continuous integration is one that I recommend to any application builder out there. Thank you for reading my second devlog about creating a Spring pipeline.</p>";

				const frontmatter = {"title":"Spring pipeline","description":"Creating Java Spirng pipeline using GitHub Actions and Jenkins","pubDate":"Aug 12, 2024","heroImage":"/blog/spring-pipeline/banner.png"};
				const file = "C:/tomcats/Personal-Portfolio/astro-portfolio/cyan-comet/src/content/blog/Spring-pipeline.md";
				const url = undefined;
				function rawContent() {
					return "\r\nHello to whoever is reading this. This is my second entry into the devlog of creating a web application. In this post, I’ll explain the automation I use for the Spring application and describe my system for deployment, testing, and code quality.\r\n\r\nHere is a quick overview of how my pipeline works.\r\n\r\n![Pipelien diagram](/blog/spring-pipeline/pipeline.svg)\r\n\r\n# Code repository\r\n\r\nThe code repository used throughout the project is GitHub, which is a reliable cloud-based repository service. Also, GitHub provides an Actions feature that can be used for CI/CD use cases, which is one of the reasons why I chose GitHub for this project. The quick and reliable use of GitHub Actions is essential for my needs.\r\n\r\nFor my use case, I wanted a way to build the JAR file after merging or pushing to the main branch. I know that build files, or in other words, the 'Artifact,' should ideally be stored in a separate repository called an Artifact repository, which manages only the artifacts for a given project. This approach provides traceability and the option to revert to an older version of the artifact if a problem arises. However, since this is my first time creating a CI/CD pipeline, I wanted to keep things simple and add features as the project progresses. In a sense, I'm keeping scalability in mind but not focusing on it until the complete skeleton is up and running.\r\n\r\nMy GitHub Actions are simple and are used just to detect a merge or push to the main branch and build a JAR artifact to be deployed.\r\n\r\n```\r\nname: Gradle Build\r\n\r\non:\r\n  push:\r\n    branches: [ main ]\r\n  pull_request:\r\n    branches: [ main ]\r\n\r\njobs:\r\n  build:\r\n    runs-on: ubuntu-latest\r\n\r\n    steps:\r\n      - uses: actions/checkout@v2\r\n\r\n      - name: Set up JDK 17\r\n        uses: actions/setup-java@v2\r\n        with:\r\n          java-version: 17\r\n          distribution: 'adopt'\r\n\r\n      - name: Grant execute permission for gradlew\r\n        working-directory: volts-server\r\n        run: chmod +x gradlew\r\n\r\n      - name: Build with Gradle\r\n        working-directory: volts-server\r\n        run: ./gradlew build\r\n\r\n      - name: List build directory\r\n        working-directory: volts-server\r\n        run: ls -la build/libs\r\n\r\n      - name: Upload JAR file\r\n        uses: actions/upload-artifact@v3\r\n        with:\r\n          working-directory: volts-server\r\n          name: my-app-build\r\n          path: build/libs/*.jar\r\n\r\n      - name: Commit JAR file to repository\r\n        working-directory: volts-server\r\n        run: |\r\n          git config user.name \"UserName\"\r\n          git config user.email \"user@mail.com\"\r\n          git add build/libs/*.jar\r\n          git commit -m \"Add build artifacts\"\r\n          git push origin main\r\n        env:\r\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\r\n```\r\n\r\n# Jenkins\r\n\r\nI use Jenkins on the server where the application will be deployed. I understand that deployment services should ideally be on a separate machine or virtual machine, but for simplicity's sake, everything is on the same machine. The Jenkins pipeline is responsible for getting the build artifact (the JAR file), creating a Docker instance, and starting it up. However, before deployment, the code is run through SonarQube. SonarQube is a service for code quality, test coverage, code issues, and overall code assessment. SonarQube is set up as a Docker container running on the same machine. As of now, the Spring application is deployed regardless of whether the SonarQube Quality Gate fails. I chose to deploy to Docker because containers are easier and quicker to manage. The faster you use what you know, the quicker your app will be ready for use.\r\n\r\n```\r\npipeline {\r\n    agent any\r\n\r\n    environment {\r\n        DOCKER_IMAGE = \"100volts-server:latest\"\r\n        GITHUB_REPO = \"https://github.com/100volts/100volts-server.git\"\r\n        DOCKERFILE_PATH = \"volts-server/Dockerfile\"\r\n        BRANCH_NAME = \"main\"\r\n        SONARQUBE_SERVER = \"sonar-volts\"\r\n    }\r\n\r\n    stages {\r\n        stage('Checkout') {\r\n            steps {\r\n                git branch: \"${BRANCH_NAME}\", url: \"${GITHUB_REPO}\"\r\n            }\r\n        }\r\n\r\n        stage('Scan') {\r\n            steps {\r\n                dir('volts-server') {\r\n                    sh 'chmod +x ./gradlew'\r\n\r\n                    withSonarQubeEnv(installationName: \"${SONARQUBE_SERVER}\") {\r\n                        sh './gradlew clean build sonarqube'\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        stage('Build Docker Image') {\r\n            steps {\r\n                script {\r\n                    docker.build(\"${DOCKER_IMAGE}\", \"-f ${DOCKERFILE_PATH} volts-server/\")\r\n                }\r\n            }\r\n        }\r\n\r\n        stage('Run Docker Container') {\r\n            steps {\r\n                script {\r\n                    sh \"docker stop 100volts-server || true\"\r\n                    sh \"docker rm 100volts-server || true\"\r\n\r\n                    sh \"docker run -d --name 100volts-server -p 8081:8081 ${DOCKER_IMAGE} --restart=always\"\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    post {\r\n        always {\r\n            // Clean up workspace\r\n            cleanWs()\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# Finishing notes\r\n\r\nCreating and managing a pipeline like this has greatly improved my scripting skills. It was exciting to build something that will save a lot of time in the long run. All in all, the exercise in continuous integration is one that I recommend to any application builder out there. Thank you for reading my second devlog about creating a Spring pipeline.\r\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":1,"slug":"code-repository","text":"Code repository"},{"depth":1,"slug":"jenkins","text":"Jenkins"},{"depth":1,"slug":"finishing-notes","text":"Finishing notes"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
