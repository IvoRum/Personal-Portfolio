const id = "Spring-pipeline.md";
						const collection = "blog";
						const slug = "spring-pipeline";
						const body = "\r\nHello to whoever is reading this. This is my second entry into the devlog of creating a web application. In this post, Iâ€™ll explain the automation I use for the Spring application and describe my system for deployment, testing, and code quality.\r\n\r\nHere is a quick overview of how my pipeline works.\r\n\r\n![Pipelien diagram](/blog/spring-pipeline/pipeline.svg)\r\n\r\n# Code repository\r\n\r\nThe code repository used throughout the project is GitHub, which is a reliable cloud-based repository service. Also, GitHub provides an Actions feature that can be used for CI/CD use cases, which is one of the reasons why I chose GitHub for this project. The quick and reliable use of GitHub Actions is essential for my needs.\r\n\r\nFor my use case, I wanted a way to build the JAR file after merging or pushing to the main branch. I know that build files, or in other words, the 'Artifact,' should ideally be stored in a separate repository called an Artifact repository, which manages only the artifacts for a given project. This approach provides traceability and the option to revert to an older version of the artifact if a problem arises. However, since this is my first time creating a CI/CD pipeline, I wanted to keep things simple and add features as the project progresses. In a sense, I'm keeping scalability in mind but not focusing on it until the complete skeleton is up and running.\r\n\r\nMy GitHub Actions are simple and are used just to detect a merge or push to the main branch and build a JAR artifact to be deployed.\r\n\r\n```\r\nname: Gradle Build\r\n\r\non:\r\n  push:\r\n    branches: [ main ]\r\n  pull_request:\r\n    branches: [ main ]\r\n\r\njobs:\r\n  build:\r\n    runs-on: ubuntu-latest\r\n\r\n    steps:\r\n      - uses: actions/checkout@v2\r\n\r\n      - name: Set up JDK 17\r\n        uses: actions/setup-java@v2\r\n        with:\r\n          java-version: 17\r\n          distribution: 'adopt'\r\n\r\n      - name: Grant execute permission for gradlew\r\n        working-directory: volts-server\r\n        run: chmod +x gradlew\r\n\r\n      - name: Build with Gradle\r\n        working-directory: volts-server\r\n        run: ./gradlew build\r\n\r\n      - name: List build directory\r\n        working-directory: volts-server\r\n        run: ls -la build/libs\r\n\r\n      - name: Upload JAR file\r\n        uses: actions/upload-artifact@v3\r\n        with:\r\n          working-directory: volts-server\r\n          name: my-app-build\r\n          path: build/libs/*.jar\r\n\r\n      - name: Commit JAR file to repository\r\n        working-directory: volts-server\r\n        run: |\r\n          git config user.name \"UserName\"\r\n          git config user.email \"user@mail.com\"\r\n          git add build/libs/*.jar\r\n          git commit -m \"Add build artifacts\"\r\n          git push origin main\r\n        env:\r\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\r\n```\r\n\r\n# Jenkins\r\n\r\nI use Jenkins on the server where the application will be deployed. I understand that deployment services should ideally be on a separate machine or virtual machine, but for simplicity's sake, everything is on the same machine. The Jenkins pipeline is responsible for getting the build artifact (the JAR file), creating a Docker instance, and starting it up. However, before deployment, the code is run through SonarQube. SonarQube is a service for code quality, test coverage, code issues, and overall code assessment. SonarQube is set up as a Docker container running on the same machine. As of now, the Spring application is deployed regardless of whether the SonarQube Quality Gate fails. I chose to deploy to Docker because containers are easier and quicker to manage. The faster you use what you know, the quicker your app will be ready for use.\r\n\r\n```\r\npipeline {\r\n    agent any\r\n\r\n    environment {\r\n        DOCKER_IMAGE = \"100volts-server:latest\"\r\n        GITHUB_REPO = \"https://github.com/100volts/100volts-server.git\"\r\n        DOCKERFILE_PATH = \"volts-server/Dockerfile\"\r\n        BRANCH_NAME = \"main\"\r\n        SONARQUBE_SERVER = \"sonar-volts\"\r\n    }\r\n\r\n    stages {\r\n        stage('Checkout') {\r\n            steps {\r\n                git branch: \"${BRANCH_NAME}\", url: \"${GITHUB_REPO}\"\r\n            }\r\n        }\r\n\r\n        stage('Scan') {\r\n            steps {\r\n                dir('volts-server') {\r\n                    sh 'chmod +x ./gradlew'\r\n\r\n                    withSonarQubeEnv(installationName: \"${SONARQUBE_SERVER}\") {\r\n                        sh './gradlew clean build sonarqube'\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        stage('Build Docker Image') {\r\n            steps {\r\n                script {\r\n                    docker.build(\"${DOCKER_IMAGE}\", \"-f ${DOCKERFILE_PATH} volts-server/\")\r\n                }\r\n            }\r\n        }\r\n\r\n        stage('Run Docker Container') {\r\n            steps {\r\n                script {\r\n                    sh \"docker stop 100volts-server || true\"\r\n                    sh \"docker rm 100volts-server || true\"\r\n\r\n                    sh \"docker run -d --name 100volts-server -p 8081:8081 ${DOCKER_IMAGE} --restart=always\"\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    post {\r\n        always {\r\n            // Clean up workspace\r\n            cleanWs()\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# Finishing notes\r\n\r\nCreating and managing a pipeline like this has greatly improved my scripting skills. It was exciting to build something that will save a lot of time in the long run. All in all, the exercise in continuous integration is one that I recommend to any application builder out there. Thank you for reading my second devlog about creating a Spring pipeline.\r\n";
						const data = {title:"Spring pipeline",description:"Creating Java Spirng pipeline using GitHub Actions and Jenkins",pubDate:new Date(1723410000000),heroImage:"/blog/spring-pipeline/banner.png"};
						const _internal = {
							type: 'content',
							filePath: "C:/tomcats/Personal-Portfolio/astro-portfolio/cyan-comet/src/content/blog/Spring-pipeline.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
